import"./modulepreload-polyfill-B5Qt9EMX.js";class T{Test(){return this.onLine=navigator.onLine,this.onLine}}class v{getLastImagery(){return new Promise(()=>!0)}async cacheImagery(){return new Promise(()=>!0)}}class M{constructor(t,e,s,a,n,r){this.id=t,this.images=e,this.bbox=s,this.date=a,this.satellite=n,this.collections=r}}class d extends M{constructor(t,e,s,a,n,r){super(t,e,s,a,n,r),this.id=t,this.images=e,this.bbox=s,this.date=a,this.satellite=n,this.collections=r}static fromJson(t){return new d(t.id,new Map(Object.entries(t.images).map(([e,s])=>[e,s])),t.bbox,new Date(t.date),t.satellite,t.collections)}toJson(){return{id:this.id,images:Object.fromEntries(this.images),bbox:this.bbox,date:this.date.toISOString(),satellite:this.satellite,collections:this.collections}}}class h extends d{constructor(t){super("Error",new Map,[[0,0],[0,0]],new Date(0),"Error",[]),this.message=t}}class R{async getRGBImagery(t){const e="https://gibs.earthdata.nasa.gov/wms/epsg4326/best/wms.cgi";try{const s=t.width||512,a=t.height||512,n=`${t.bbox[0][0]},${t.bbox[0][1]},${t.bbox[1][0]},${t.bbox[1][1]}`,r=t.date.toISOString().split("T")[0],l=`${e}?SERVICE=WMS&REQUEST=GetMap&VERSION=1.3.0&LAYERS=MODIS_Terra_CorrectedReflectance_TrueColor&TIME=${r}&BBOX=${n}&CRS=EPSG:4326&WIDTH=${s}&HEIGHT=${a}&FORMAT=image/png`;console.log(l);const m=await fetch(l);if(!m.ok)return new h("Failed to fetch RGB imagery");const i=await m.arrayBuffer();return d.fromJson({id:crypto.randomUUID(),images:{main:{data:i,mimeType:"image/png"}},bbox:t.bbox,date:r,satellite:"MODIS",collections:["MODIS_Terra_CorrectedReflectance_TrueColor"]})}catch(s){return console.error(s),new h("Server Error")}}async getNDVIImagery(t){const e="https://gibs.earthdata.nasa.gov/wms/epsg4326/all/wms.cgi";try{const s=t.width||512,a=t.height||512,n=`${t.bbox[0][0]},${t.bbox[0][1]},${t.bbox[1][0]},${t.bbox[1][1]}`,r=t.date.toISOString().split("T")[0],l="MODIS_Terra_L3_NDVI_16Day",m=`${e}?SERVICE=WMS&REQUEST=GetMap&VERSION=1.3.0&LAYERS=${l}&TIME=${r}&BBOX=${n}&CRS=EPSG:4326&WIDTH=${s}&HEIGHT=${a}&STYLES=&TRANSPARENT=FALSE&FORMAT=image/png`;console.log(m);const i=await fetch(m);if(!i||!i.ok)return console.error("Red band fetch failed",i),new h("Failed to fetch Red band");const D=await i.arrayBuffer();return d.fromJson({id:crypto.randomUUID(),images:{ndvi:{data:D,mimeType:"image/png"}},bbox:t.bbox,date:r,satellite:"MODIS",collections:[l]})}catch(s){return console.error(s),new h("Server Error")}}}class B{}class C extends B{constructor(t,e,s){super(),this.remoteDataSource=t,this.localDataSource=e,this.networkTest=s}async getRGBImagery(t){return await this.getImagery(this.remoteDataSource.getRGBImagery,t)}async getNDVIImagery(t){return await this.getImagery(this.remoteDataSource.getNDVIImagery,t)}async getImagery(t,e){if(this.networkTest.Test()){console.log("trying imagery");try{let s=await t(e);return console.log("got Imagery"),s}catch{return new h("Failed to get RGB Imagery")}}else try{return await this.localDataSource.getLastImagery()}catch{return new h("Unable to retrieve Cached Imagery")}}}class k{constructor(t){this.repository=t}async executeRGB(t){return await this.repository.getRGBImagery(t)}async executeNDVI(t){return await this.repository.getNDVIImagery(t)}}class ${constructor(){this.listeners=[],this.state=this.getInitialState}subscribe(t){this.listeners.push(t),t(this.state)}emit(t){this.state=t;for(const e of this.listeners)e(t)}async dispatch(t){for await(const e of this.mapStatetoEvent(t))this.emit(e)}}class w{constructor(t,e){this.bbox=t,this.date=e}}class O extends w{constructor(t,e){super(t,e)}}class I extends w{constructor(t,e){super(t,e)}}class p{}class x extends p{}class y extends p{}class b extends p{constructor(t){super(),this.imagery=t}}let f=class extends p{constructor(t){super(),this.errMsg=t}};class N extends ${constructor(t){super(),this._getImagery=t}get getInitialState(){return new x}async*mapStatetoEvent(t){if(t instanceof O){yield new y;const e=await this._getImagery.executeRGB({bbox:t.bbox,date:t.date});e instanceof h?yield new f("Unable to get Image"):yield new b(e)}else if(t instanceof I){yield new y;const e=await this._getImagery.executeNDVI({bbox:t.bbox,date:t.date});e instanceof h?yield new f("Unable to get Image"):yield new b(e)}}}class S{constructor(t,e="div"){this.mounted=!1,this.root=document.createElement(e),this.root.className=t}onMount(){}onDestroy(){}mount(t=document.body){this.mounted||(t.appendChild(this.root),this.mounted=!0,this.onMount())}destroy(){this.mounted&&(this.onDestroy(),this.root.remove(),this.mounted=!1)}show(){this.root.style.display=""}hide(){this.root.style.display="none"}get element(){return this.root}}class P extends S{constructor(){super("map_widget"),this.markers=[],this.pointListeners=[],this.onClick=t=>{const e=L.marker(t.latlng,{draggable:!0}).addTo(this.map);this.markers.push(e),e.on("dragend",()=>{this.emitPointsChanged()}),this.markers.length>2&&this.markers.shift()?.remove(),this.emitPointsChanged()},this.map=L.map("map").setView([50.5,-.09],5),L.tileLayer("https://tiles.stadiamaps.com/tiles/alidade_smooth/{z}/{x}/{y}{r}.{ext}",{minZoom:0,maxZoom:20,attribution:'&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> &copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',ext:"png"}).addTo(this.map),this.map.on("click",this.onClick)}onPointsChanged(t){this.pointListeners.push(t)}emitPointsChanged(){const t=this.getPoints();t instanceof Error||this.pointListeners.forEach(e=>e(t))}getPoints(){return this.markers.map(t=>t.getLatLng())}setPoint(t,e,s){const a=this.markers[t];if(!a){const n=L.icon({iconUrl:"../../../../../assets/Pasted image.png",iconSize:[30,35],iconAnchor:[10,34]}),r=L.marker([1,1],{draggable:!0,icon:n}).addTo(this.map);this.markers.push(r)}a.setLatLng([e,s]),this.emitPointsChanged()}}class _ extends S{constructor(t){super("sidebar"),this.inputs=[],this.map=t}snapToMODIS16Day(t){const e=new Date(Date.UTC(2e3,0,1)),s=1440*60*1e3,a=Math.floor((t.getTime()-e.getTime())/s),r=Math.floor(a/16)*16;return new Date(e.getTime()+r*s)}bindFetchButton(){const t=this.root.querySelector("#fetch-imagery");t&&t.addEventListener("click",()=>{const e=this.map.getPoints();if(e.length<2){alert("Please add 2 points before fetching imagery.");return}const s=e.map(i=>i.lat),a=e.map(i=>i.lng),n=[[Math.min(...s),Math.min(...a)],[Math.max(...s),Math.max(...a)]];console.log("Computed bbox:",n);const r=45,l=new Date(Date.now()-r*24*60*60*1e3),m=this.snapToMODIS16Day(l);E.dispatch(new I(n,m))})}onMount(){this.render(),this.bind(),this.bindFetchButton(),this.map.onPointsChanged(t=>{t.forEach((e,s)=>{!e||!this.inputs[s]||(this.inputs[s].value=`${e.lat.toFixed(5)}, ${e.lng.toFixed(5)}`)})})}render(){this.root.innerHTML=`
    <h2 style='font-family: "BBH Bogle"; font-size:60px; margin-top:0; margin-bottom:8px; color:green'>
      CHECKYOURFORESTS
    </h2>
    <p style ='white-space: pre-line'>Click on the map or edit coordinates below.
      These points represent the maximum 
      and minimum corners of your selection.

    Darker greens represent areas of high vegetation and 
    light greeb areas represent less vegitated areas.</p>
    <div class="divider"></div>

    ${[0,1].map(t=>`
      <div class="input-row" style="margin-bottom: 8px;">
        <label>Point ${t}:</label>
        <input data-index="${t}" placeholder="lat, lng" />
      </div>
    `).join("")}

    <button id="fetch-imagery" style="margin-top:16px; padding:8px 12px; display:block;">
      Fetch Imagery
    </button>
  `,this.inputs=Array.from(this.root.querySelectorAll("input"))}bind(){this.inputs.forEach(t=>{t.addEventListener("change",()=>{const e=Number(t.dataset.index),[s,a]=t.value.split(",").map(Number);!Number.isNaN(s)&&!Number.isNaN(a)&&this.map.setPoint(e,s,a)})})}}var G=new R,U=new v,V=new T,A=new C(G,U,V),F=new k(A);const E=new N(F);let c=null,u=null,g=null;E.subscribe(async o=>{if(o instanceof x){if(console.log("Empty"),!c){c=new P;const t=document.getElementById("map");c.mount(t)}if(!u){u=new _(c);const t=document.getElementById("sidebar");u.mount(t);let e=c.map.getCenter();c.map.on("move",()=>{const s=c.map.getCenter(),a=c.map.latLngToContainerPoint(e),n=c.map.latLngToContainerPoint(s),r=n.x-a.x,l=n.y-a.y,m=Math.max(-15,Math.min(15,r*.3)),i=Math.max(-15,Math.min(15,l*.3));t.style.transform=`translate(${m}px, ${i}px)`,e=s})}}if(o instanceof y&&console.log("Loading imagery..."),o instanceof b){let t;const e=o.imagery,s=e.images.get("ndvi");if(!(s.data instanceof ArrayBuffer))throw new Error("Unsupported image data type");t=new Blob([s.data],{type:s.mimeType});const a=URL.createObjectURL(t);g&&(c?.map.removeLayer(g),g=null),g=L.imageOverlay(a,L.latLngBounds([e.bbox[0][0],e.bbox[0][1]],[e.bbox[1][0],e.bbox[1][1]])),g.addTo(c.map)}o instanceof Error&&console.error(o.message)});
